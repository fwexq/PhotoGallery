def dig_pow(n, p):
    string = list(str(n))
    sum = 0
    for i in string:
        sum += pow(int(i), p)
        p += 1

    for j in range(999999):
        if n * j == sum:
            return j
    return -1




print(dig_pow(46288, 3))
# Некоторые числа обладают забавными свойствами. Например:
# 89 --> 8¹ + 9² = 89 * 1
# 695 --> 6² + 9³ + 5⁴= 1390 = 695 * 2
# 46288 --> 4³ + 6⁴+ 2⁵ + 8⁶ + 8⁷ = 2360688 = 46288 * 51
# Даны положительное целое число n, записанное в виде abcd... (a, b, c, d... являются цифрами), и положительное целое число p
# мы хотим найти положительное целое число k, если оно существует,
# такая, что сумма цифр числа n, взятых в последовательных степенях числа p, равна k * n.
# Другими словами:
# Существует ли целое число k, такое как: (a ^ p + b ^ (p+1) + c ^ (p+2) + d ^ (p+3) + ...) = n * k
# Если это так, мы вернем k, если нет, вернем -1.
# Примечание: n и p всегда задаются как строго положительные целые числа.
